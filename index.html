function scheduleCrossfade() {
  const audio = getActiveAudio();

  // Always use onended to continue mixing
  audio.onended = () => {
    goToNextTrack(true);
  };

  // If duration is available, do timed crossfade
  audio.ontimeupdate = () => {
    if (!isPlaying || isCrossfading) return;

    if (audio.duration && isFinite(audio.duration)) {
      const timeLeft = audio.duration - audio.currentTime;
      if (timeLeft <= crossfadeSeconds && crossfadeSeconds < audio.duration) {
        startCrossfadeToNext();
      }
    }
  };
}

// Update metadata handler
audioA.onloadedmetadata = audioB.onloadedmetadata = function () {
  const track = playlist[currentIndex];
  if (!track) return;

  if (!track.duration && this.duration && isFinite(this.duration)) {
    track.duration = this.duration;
    renderPlaylist();
  }
};
